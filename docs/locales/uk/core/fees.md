---
title: Плата на Solana
sidebarSortOrder: 3
description:
  Дізнайтеся про структуру плати на Solana, включаючи транзакційні збори,
  пріоритизаційні збори та витрати на оренду. Зрозумійте, як обчислюється,
  збирається та розподіляється плата в мережі.
keywords:
  - плата за інструкцію
  - плата за обробку
  - плата за збереження
  - оренда
  - газ
  - гвей
altRoutes:
  - /docs/uk/core/rent
  - /docs/uk/intro/rent
  - /docs/uk/intro/transaction_fees
  - /docs/uk/intro/transaction-fees
  - /docs/uk/core/runtime
---

Блокчейн Solana має кілька типів плати та витрат, які виникають під час
використання мережі без дозволу. Вони поділяються на кілька специфічних типів:

- **Транзакційні збори** — плата за обробку транзакцій/інструкцій валідаторами.
- **Пріоритизаційні збори** — додаткова плата для підвищення порядку обробки
  транзакцій.
- **Оренда** — утримуваний баланс для збереження даних в ончейні.

## Транзакційні збори

Мала плата, яка сплачується за обробку логіки (інструкції) у програмі в ончейні
на блокчейні Solana, називається "_транзакційною платою_".

Кожна [транзакція](/docs/uk/core/transactions.md#transaction), яка містить одну
або більше [інструкцій](/docs/uk/core/transactions.md#instruction), надсилається
через мережу, де її обробляє поточний лідер-валідатор. Після підтвердження як
глобальної транзакції ця "транзакційна плата" сплачується мережі для підтримки
економічної моделі блокчейна Solana.

> Транзакційні збори відрізняються від плати за збереження даних в обліковому
> записі, відомої як [оренда](#rent). Транзакційні збори сплачуються за обробку
> інструкцій у мережі Solana, а депозит оренди утримується в обліковому записі
> для збереження даних в блокчейні та може бути повернутий.

На даний момент базова транзакційна плата в Solana встановлена на рівні 5000
лампортів за підпис. На додаток до цієї базової плати, можуть бути додані
додаткові [пріоритизаційні збори](#prioritization-fee).

### Навіщо сплачувати транзакційні збори?

Транзакційні збори пропонують багато переваг у економічній моделі Solana,
зокрема вони:

- Забезпечують компенсацію мережі валідаторів за витрачені ресурси CPU/GPU для
  обробки транзакцій.
- Зменшують спам у мережі, запроваджуючи реальну вартість транзакцій.
- Забезпечують довгострокову економічну стабільність мережі через протокольно
  захоплену мінімальну плату за транзакцію.

### Основи економічної моделі

Багато блокчейн-мереж (включаючи Bitcoin та Ethereum) покладаються на інфляційні
"протокольні нагороди" для короткострокової підтримки безпеки мережі. У
довгостроковій перспективі ці мережі все більше покладаються на "транзакційні
збори" для підтримки безпеки.

Те саме стосується Solana. Зокрема:

- Фіксована частка (спочатку 50%) кожної транзакційної плати "спалюється"
  (знищується), решта надходить до поточного
  [лідера](/docs/uk/terminology.md#leader), який обробляє транзакцію.
- Запланована глобальна інфляційна ставка забезпечує джерело
  [нагород](https://docs.anza.xyz/implemented-proposals/staking-rewards), які
  розподіляються серед [валідаторів Solana](https://docs.anza.xyz/operations).

### Збір плати

Транзакції повинні мати щонайменше один обліковий запис, який підписав
транзакцію та може бути змінений. Ці "записувані підписуючі облікові записи"
серіалізуються першими у списку облікових записів, і перший з них завжди
використовується як "платник плати".

Перед обробкою будь-яких інструкцій транзакції баланс облікового запису платника
плати
[вираховується](https://github.com/anza-xyz/agave/blob/b7bbe36918f23d98e2e73502e3c4cba78d395ba9/runtime/src/bank.rs#L4045-L4064)
для оплати транзакційних зборів. Якщо баланс платника плати недостатній для
покриття зборів, обробка транзакції припиняється і вона визнається невдалою.

Якщо баланс був достатнім, плата буде вирахувана, і виконання інструкцій
транзакції почнеться. Якщо будь-яка з інструкцій призведе до помилки, обробка
транзакції буде припинена, і зрештою вона буде записана як невдала транзакція в
книзі Solana. Плата все одно буде зібрана за ці невдалі транзакції.

Якщо будь-яка з інструкцій повертає помилку або порушує обмеження часу
виконання, всі зміни облікових записів **_крім_** вирахування транзакційної
плати будуть скасовані. Це тому, що мережа валідаторів вже витратила
обчислювальні ресурси для збору транзакцій та початку їх обробки.

### Розподіл плати

Транзакційні збори
[частково спалюються](https://github.com/anza-xyz/agave/blob/b7bbe36918f23d98e2e73502e3c4cba78d395ba9/runtime/src/bank/fee_distribution.rs#L55-L64),
а решта зборів збираються валідатором, який створив блок, у якому включені
відповідні транзакції. Зокрема,
[50% спалюються](https://github.com/anza-xyz/agave/blob/b7bbe36918f23d98e2e73502e3c4cba78d395ba9/sdk/program/src/fee_calculator.rs#L79),
а
[50% розподіляються](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62)
валідатору, який створив блок.

### Чому спалюються частина зборів?

Як згадано вище, фіксована частка кожної транзакційної плати "спалюється"
(знищується). Це зроблено для зміцнення економічної цінності SOL і підтримки
безпеки мережі. На відміну від системи, де всі транзакційні збори повністю
спалюються, лідери все ще мають стимул включати якомога більше транзакцій у свої
слоти (можливість створити блок).

Спалені збори також можуть допомогти запобігти зловмисним валідаторам у
цензуруванні транзакцій через врахування в
[виборі форку](/docs/uk/terminology.md#fork).

#### Приклад атаки:

У випадку
[форку Proof of History (PoH)](/docs/uk/terminology.md#proof-of-history-poh) з
лідером, що займається цензурою або зловживанням:

- через втрати зборів, що виникають через цензуру, очікується, що загальні
  збори, які будуть спалені, будуть **_меншими_**, ніж у порівнянному чесному
  форку;
- якщо лідер, який займається цензурою, хоче компенсувати ці втрачені
  протокольні збори, він повинен буде самостійно замінити спалені збори на
  своєму форку;
- таким чином, потенційно зменшуючи стимул до цензури в першу чергу.

### Обчислення транзакційних зборів

Повна плата за конкретну транзакцію розраховується на основі двох основних
частин:

- Статично встановлена базова плата за підпис, і
- Обчислювальні ресурси, використані під час транзакції, виміряні у
  "[обчислювальних одиницях](/docs/uk/terminology.md#compute-units)".

Оскільки кожна транзакція може вимагати різної кількості обчислювальних
ресурсів, кожній транзакції виділяється максимальна кількість _обчислювальних
одиниць_ у рамках "обчислювального бюджету".

## Обчислювальний бюджет

Щоб запобігти зловживанню обчислювальними ресурсами, кожній транзакції
виділяється "обчислювальний бюджет". Цей бюджет визначає:

- обчислювальні витрати, пов'язані з різними типами операцій, які може
  виконувати транзакція (обчислювальні одиниці, спожиті на операцію),
- максимальну кількість обчислювальних одиниць, які може спожити транзакція
  (ліміт обчислювальних одиниць),
- та операційні межі, яких має дотримуватися транзакція (наприклад, ліміти
  розміру даних облікового запису).

Коли транзакція вичерпує свій обчислювальний бюджет (вичерпання обчислювального
бюджету) або перевищує межі, наприклад, намагається перевищити
[максимальну глибину стеку викликів](https://github.com/anza-xyz/agave/blob/b7bbe36918f23d98e2e73502e3c4cba78d395ba9/program-runtime/src/compute_budget.rs#L138)
або
[максимальний розмір завантажених даних облікового запису](#accounts-data-size-limit),
виконання транзакції припиняється, і повертається помилка. Це призводить до
невдалої транзакції та жодних змін стану (окрім збору плати за транзакцію).

### Ліміт розміру даних облікового запису

Транзакція може встановлювати максимальну кількість байтів даних облікового
запису, які їй дозволено завантажувати, включивши інструкцію
`SetLoadedAccountsDataSizeLimit` (не перевищуючи абсолютний максимум часу
виконання). Якщо `SetLoadedAccountsDataSizeLimit` не надано, транзакція за
замовчуванням використовує значення часу виконання
[`MAX_LOADED_ACCOUNTS_DATA_SIZE_BYTES`](https://github.com/anza-xyz/agave/blob/b7bbe36918f23d98e2e73502e3c4cba78d395ba9/program-runtime/src/compute_budget_processor.rs#L137-L139).

Функцію `ComputeBudgetInstruction::set_loaded_accounts_data_size_limit` можна
використовувати для створення цієї інструкції.

```rust
let instruction = ComputeBudgetInstruction::set_loaded_accounts_data_size_limit(100_000);
```

### Обчислювальні одиниці

Усі операції, виконані ончейн у рамках транзакції, вимагають різного обсягу
обчислювальних ресурсів, які витрачаються валідаторами під час обробки
(обчислювальна вартість). Найменшою одиницею виміру цих ресурсів є
_"обчислювальна одиниця"_.

Під час обробки транзакції обчислювальні одиниці поступово споживаються кожною з
її інструкцій, виконуваних ончейн (вичерпуючи бюджет). Оскільки кожна інструкція
виконує різну логіку (запис у облікові записи, CPI, виконання системних викликів
тощо), кожна може споживати
[різну кількість](https://github.com/anza-xyz/agave/blob/b7bbe36918f23d98e2e73502e3c4cba78d395ba9/program-runtime/src/compute_budget.rs#L133-L178)
обчислювальних одиниць.

> Програма може записувати деталі про використання своїх обчислювальних
> ресурсів, включаючи залишок у виділеному обчислювальному бюджеті. Більше
> інформації ви можете знайти в цьому посібнику з
> [оптимізації використання обчислювальних ресурсів](/content/guides/advanced/how-to-optimize-compute.md).

Кожній транзакції виділяється
[ліміт обчислювальних одиниць](#compute-unit-limit), або за замовчуванням
встановлений часом виконання, або шляхом явного запиту на вищий ліміт. Якщо
транзакція перевищує свій ліміт обчислювальних одиниць, її обробка зупиняється,
що призводить до невдалої транзакції.

Нижче наведено кілька поширених операцій, які мають обчислювальну вартість:

- виконання інструкцій
- передача даних між програмами
- виконання системних викликів
- використання системних змінних (sysvars)
- логування за допомогою макросу `msg!`
- логування відкритих ключів
- створення програмних адрес (PDAs)
- міжпрограмні виклики (CPI)
- криптографічні операції

> Для [міжпрограмних викликів](/docs/uk/core/cpi.md) викликана інструкція
> успадковує обчислювальний бюджет і ліміти свого батька. Якщо викликана
> інструкція споживає залишок бюджету транзакції або перевищує ліміт, весь
> ланцюжок викликів і обробка транзакції верхнього рівня зупиняються.

Детальнішу інформацію про всі операції, які споживають обчислювальні одиниці, ви
можете знайти в
[ComputeBudget](https://github.com/anza-xyz/agave/blob/b7bbe36918f23d98e2e73502e3c4cba78d395ba9/program-runtime/src/compute_budget.rs#L19-L123)
в часі виконання Solana.

### Ліміт обчислювальних одиниць

Кожна транзакція має максимальну кількість обчислювальних одиниць (CU), які вона
може спожити, що називається _"лімітом обчислювальних одиниць"_. У часі
виконання Solana встановлено абсолютний максимальний ліміт
[1,4 мільйона CU](https://github.com/anza-xyz/agave/blob/b7bbe36918f23d98e2e73502e3c4cba78d395ba9/program-runtime/src/compute_budget_processor.rs#L19)
на транзакцію та за замовчуванням
[200 тисяч CU на інструкцію](https://github.com/anza-xyz/agave/blob/b7bbe36918f23d98e2e73502e3c4cba78d395ba9/program-runtime/src/compute_budget_processor.rs#L18).

Транзакція може запитувати більш конкретний і оптимальний ліміт обчислювальних
одиниць, включивши одну інструкцію `SetComputeUnitLimit`. Це може бути як вищий,
так і нижчий ліміт. Але він ніколи не може перевищувати абсолютний максимальний
ліміт на транзакцію.

Хоча ліміт обчислювальних одиниць за замовчуванням підходить для простих
транзакцій, він часто є менш оптимальним (як для часу виконання, так і для
користувача). Для складніших транзакцій, наприклад, виклику програм, що
виконують декілька CPI, може знадобитися запит вищого ліміту обчислювальних
одиниць для транзакції.

Запит оптимальних лімітів обчислювальних одиниць для вашої транзакції є важливим
для зменшення витрат на транзакцію та кращого планування вашої транзакції в
мережі. Гаманці, dApps та інші сервіси повинні переконатися, що їхні запити на
обчислювальні одиниці є оптимальними, щоб забезпечити найкращий досвід для своїх
користувачів.

> Для отримання додаткової інформації та найкращих практик прочитайте цей
> посібник про
> [запит оптимальних лімітів обчислювальних ресурсів](/content/guides/advanced/how-to-request-optimal-compute.md).

### Ціна обчислювальної одиниці

Якщо транзакція бажає сплатити вищу плату, щоб підвищити пріоритетність її
обробки, вона може встановити _"ціну обчислювальної одиниці"_. Ця ціна, у
поєднанні з [лімітом обчислювальних одиниць](#compute-unit-limit), буде
використовуватися для визначення плати за пріоритизацію транзакції.

За замовчуванням
[ціна обчислювальної одиниці не встановлена](https://github.com/anza-xyz/agave/blob/b7bbe36918f23d98e2e73502e3c4cba78d395ba9/program-runtime/src/compute_budget_processor.rs#L38),
що призводить до відсутності додаткової плати за пріоритизацію.

## Пріоритизаційні збори

Як частина [Compute Budget](#compute-budget), час виконання підтримує
транзакції, що сплачують **опціональну** плату, відому як _"плата за
пріоритизацію"_. Сплата цієї додаткової плати допомагає підвищити пріоритетність
транзакції у порівнянні з іншими під час обробки, що призводить до швидшого
виконання.

### Як розраховується плата за пріоритизацію

Плата за пріоритизацію транзакції розраховується шляхом множення її **_ліміту
обчислювальних одиниць_** на **_ціну обчислювальної одиниці_** (вимірюється в
_мікролампортах_). Ці значення можна встановити один раз на транзакцію,
включивши такі інструкції Compute Budget:

- [`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/b7bbe36918f23d98e2e73502e3c4cba78d395ba9/sdk/src/compute_budget.rs#L47-L50)
  — встановлення максимальної кількості обчислювальних одиниць, які може спожити
  транзакція.
- [`SetComputeUnitPrice`](https://github.com/anza-xyz/agave/blob/b7bbe36918f23d98e2e73502e3c4cba78d395ba9/sdk/src/compute_budget.rs#L52-L55)
  — встановлення бажаної додаткової плати, яку транзакція готова сплатити для
  підвищення пріоритетності.

Якщо інструкція `SetComputeUnitLimit` не надана, буде використовуватися
[ліміт обчислювальних одиниць за замовчуванням](#compute-unit-limit).

Якщо інструкція `SetComputeUnitPrice` не надана, транзакція за замовчуванням
матиме найнижчий пріоритет (тобто відсутність пріоритизаційної плати).

### Як встановити плату за пріоритизацію

Плата за пріоритизацію транзакції встановлюється шляхом включення інструкції
`SetComputeUnitPrice` та, за бажанням, інструкції `SetComputeUnitLimit`. Час
виконання використовуватиме ці значення для розрахунку плати за пріоритизацію,
яка буде використовуватися для пріоритизації даної транзакції у блоці.

Ви можете створити кожну з цих інструкцій за допомогою функцій Rust або
`@solana/web3.js`. Потім кожну інструкцію можна включити в транзакцію та
надіслати до кластера як звичайно. Дивіться також
[найкращі практики](#prioritization-fee-best-practices) нижче.

На відміну від інших інструкцій усередині транзакції Solana, інструкції Compute
Budget **НЕ** вимагають жодних облікових записів. Транзакція з кількома
інструкціями одного типу завершиться невдачею.

<Callout type="caution">

Транзакції можуть містити лише **одну інструкцію кожного типу** інструкцій
обчислювального бюджету. Дублікати інструкцій призведуть до помилки
[`TransactionError::DuplicateInstruction`](https://github.com/anza-xyz/agave/blob/b7bbe36918f23d98e2e73502e3c4cba78d395ba9/sdk/src/transaction/error.rs#L143-L145)
і, зрештою, до невдачі транзакції.

</Callout>

#### Rust

Бібліотека `solana-sdk` включає функції в рамках
[`ComputeBudgetInstruction`](https://docs.rs/solana-sdk/latest/solana_sdk/compute_budget/enum.ComputeBudgetInstruction.html)
для створення інструкцій для встановлення _ліміту обчислювальних одиниць_ та
_ціни обчислювальної одиниці_.

```rust
let instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
```

```rust
let instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

#### Javascript

Бібліотека `@solana/web3.js` включає функції в класі
[`ComputeBudgetProgram`](https://solana-labs.github.io/solana-web3.js/v1.x/classes/ComputeBudgetProgram.html)
для створення інструкцій для встановлення _ліміту обчислювальних одиниць_ та
_ціни обчислювальної одиниці_.

```js
const instruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000,
});
```

```js
const instruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1,
});
```

### Найкращі практики для плати за пріоритизацію

Нижче наведено загальну інформацію про найкращі практики для пріоритизаційних
зборів. Більш детальну інформацію можна знайти в цьому посібнику про
[запит оптимального використання обчислювальних ресурсів](/content/guides/advanced/how-to-request-optimal-compute.md),
включаючи симуляцію транзакції для визначення її приблизного використання
обчислювальних ресурсів.

#### Запитуйте мінімальну кількість обчислювальних одиниць

Транзакції повинні запитувати мінімальну кількість обчислювальних одиниць,
необхідну для виконання, щоб мінімізувати збори. Також зауважте, що збори не
коригуються, якщо кількість запитаних обчислювальних одиниць перевищує фактично
спожиту кількість у виконаній транзакції.

#### Отримуйте останні пріоритизаційні збори

Перед надсиланням транзакції до кластеру ви можете скористатися методом RPC
[`getRecentPrioritizationFees`](/docs/uk/rpc/http/getRecentPrioritizationFees.mdx),
щоб отримати список останніх сплачених пріоритизаційних зборів у нещодавно
оброблених блоках вузла.

Ви можете використовувати ці дані для оцінки відповідної плати за пріоритизацію
для вашої транзакції, щоб:

(a) підвищити ймовірність її обробки кластером та (b) мінімізувати сплачені
збори.

## Оренда

Плата, що депонується на кожен
[Обліковий запис Solana](/docs/uk/core/accounts.md) для збереження його
пов'язаних даних в ончейні, називається "_орендою_". Ця плата утримується у
звичайному балансі лампортів на кожному обліковому записі та може бути повернута
під час закриття облікового запису.

> Оренда відрізняється від [транзакційних зборів](#transaction-fees). Оренда
> "сплачується" (утримується в Обліковому записі) для збереження даних на
> блокчейні Solana та може бути повернута. У той час як транзакційні збори
> сплачуються за обробку
> [інструкцій](/docs/uk/core/transactions.md#instructions) у мережі.

Усі облікові записи повинні підтримувати достатньо високий баланс лампортів
(відносно їх виділеного простору), щоб стати
[звільненими від оренди](#rent-exempt) і залишатися на блокчейні Solana.
Будь-яка транзакція, що намагається зменшити баланс облікового запису нижче його
відповідного мінімального балансу для звільнення від оренди, завершиться
невдачею (якщо тільки баланс не зменшується до нуля).

Коли власник облікового запису більше не бажає зберігати ці дані в ончейні та
доступними в глобальному стані, він може закрити обліковий запис і повернути
орендний депозит.

Це здійснюється шляхом виведення (переказу) усього балансу лампортів облікового
запису на інший обліковий запис (наприклад, ваш гаманець). Зменшивши баланс
облікового запису до рівно `0`, час виконання видалить обліковий запис і його
пов'язані дані з мережі в процесі _"[збирання сміття](#garbage-collection)"_.

### Ставка оренди

Ставка оренди Solana встановлюється на рівні всієї мережі, головним чином
базуючись на часі виконання
"[лампорти _за_ байт _за_ рік](https://github.com/anza-xyz/agave/blob/b7bbe36918f23d98e2e73502e3c4cba78d395ba9/sdk/program/src/rent.rs#L27-L34)".
Наразі ставка оренди є статичною величиною та зберігається в
[системній змінній Rent](https://docs.anza.xyz/runtime/sysvars#rent).

Ця ставка оренди використовується для розрахунку точної суми оренди, яка повинна
бути утримана в обліковому записі для виділеного простору облікового запису
(тобто кількість даних, які можуть бути збережені в обліковому записі). Чим
більше простору виділяє обліковий запис, тим вищим буде утриманий орендний
депозит.

### Звільнення від оренди

Облікові записи повинні підтримувати баланс лампортів, що перевищує мінімум,
необхідний для зберігання відповідних даних в ончейні. Це називається
"_звільненням від оренди_", а цей баланс називається "_мінімальним балансом для
звільнення від оренди_".

> Нові облікові записи (та програми) на Solana **ЗОБОВ'ЯЗАНІ** бути
> ініціалізовані з достатньою кількістю лампортів, щоб стати _звільненими від
> оренди_. Так було не завжди. Раніше час виконання періодично та автоматично
> стягував плату з кожного облікового запису, що мав баланс нижче мінімуму для
> звільнення від оренди. Зрештою, такі облікові записи знижувалися до нульового
> балансу та видалялися з глобального стану (якщо їх не поповнювали вручну).

У процесі створення нового облікового запису необхідно переконатися, що ви
депонуєте достатньо лампортів, щоб перевищити цей мінімальний баланс. Все, що
нижче цього мінімального порогу, призведе до невдачі транзакції.

Кожного разу, коли баланс облікового запису зменшується, час виконання
перевіряє, чи залишиться баланс цього облікового запису вище мінімального
балансу для звільнення від оренди. Якщо тільки баланс не знижується до рівно `0`
(закриття облікового запису), транзакції, які спричиняють падіння балансу
облікового запису нижче порогу звільнення від оренди, завершаться невдачею.

Специфічний мінімальний баланс для облікового запису, щоб стати звільненим від
оренди, залежить від поточної [ставки оренди](#rent-rate) блокчейну та бажаного
обсягу простору, який обліковий запис хоче виділити (розмір облікового запису).
Тому рекомендується використовувати RPC-метод
[`getMinimumBalanceForRentExemption`](/docs/uk/rpc/http/getMinimumBalanceForRentExemption.mdx)
для розрахунку конкретного балансу для заданого розміру облікового запису.

Суму необхідного орендного депозиту також можна оцінити за допомогою підкоманди
CLI [`solana rent`](https://docs.anza.xyz/cli/usage#solana-rent).

```shell
solana rent 15000

# output
Rent per byte-year: 0.00000348 SOL
Rent per epoch: 0.000288276 SOL
Rent-exempt minimum: 0.10529088 SOL
```

### Збирання сміття

Облікові записи, які не підтримують баланс лампортів більше нуля, видаляються з
мережі в процесі, відомому як _збирання сміття_. Цей процес виконується, щоб
зменшити загальну кількість збережених у мережі даних, які більше не
використовуються або не підтримуються.

Після успішного зменшення балансу облікового запису до рівно `0` транзакцією,
збирання сміття виконується автоматично часом виконання. Будь-яка транзакція,
яка намагається зменшити баланс облікового запису нижче його мінімального
балансу для звільнення від оренди (що не дорівнює нулю), завершиться невдачею.

<Callout type="warning">
Важливо зазначити, що збирання сміття відбувається **після** завершення виконання транзакції. Якщо є інструкція "закрити" обліковий запис, зменшивши баланс облікового запису до нуля, обліковий запис може бути "повторно відкритий" у тій самій транзакції за допомогою наступної інструкції. Якщо стан облікового запису не було очищено в інструкції "закрити", наступна інструкція "повторного відкриття" матиме той самий стан облікового запису. Це є проблемою безпеки, тому важливо знати точний момент, коли збирання сміття набирає чинності.
</Callout>

Навіть після того, як обліковий запис було видалено з мережі (через збирання
сміття), він все ще може мати транзакції, пов'язані з його адресою (або в
історії, або в майбутньому). Незважаючи на те, що блокчейн-експлорер Solana може
відображати повідомлення типу "обліковий запис не знайдено", ви все одно можете
переглядати історію транзакцій, пов'язаних із цим обліковим записом.

Ви можете прочитати
[запропоновану реалізацію](https://docs.anza.xyz/implemented-proposals/persistent-account-storage#garbage-collection)
для збирання сміття, щоб дізнатися більше.
