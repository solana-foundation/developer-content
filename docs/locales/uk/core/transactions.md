---
title: "Транзакції та Інструкції"
sidebarSortOrder: 2
description:
  Дізнайтеся про транзакції та інструкції Solana — основні будівельні блоки для
  взаємодії з блокчейном Solana. Зрозумійте структуру транзакцій і створення
  інструкцій із практичними прикладами.
---

У Solana ми надсилаємо [транзакції](/docs/uk/core/transactions#transaction), щоб
взаємодіяти з мережею. Транзакції включають одну або більше
[інструкцій](/docs/uk/core/transactions#instruction), кожна з яких представляє
конкретну операцію, що має бути оброблена. Логіка виконання інструкцій
зберігається в [програмах](/docs/uk/core/programs), розгорнутих у мережі Solana,
і кожна програма зберігає свій набір інструкцій.

Нижче наведено основні деталі щодо виконання транзакцій:

- Порядок виконання: Якщо транзакція містить декілька інструкцій, вони
  обробляються у порядку, в якому були додані до транзакції.
- Атомарність: Транзакція є атомарною, тобто вона або повністю виконується з
  успішною обробкою всіх інструкцій, або повністю провалюється. Якщо будь-яка
  інструкція у транзакції не вдається, жодна з інструкцій не буде виконана.

Для простоти можна уявити транзакцію як запит на обробку однієї або кількох
інструкцій.

![Спрощена транзакція](/assets/docs/core/transactions/transaction-simple.svg)

Уявіть транзакцію як конверт, де кожна інструкція — це документ, який ви
заповнюєте та кладете у конверт. Потім ми відправляємо конверт для обробки
документів, так само, як відправляємо транзакцію в мережу для обробки наших
інструкцій.

## Основні моменти

- Транзакції Solana складаються з інструкцій, які взаємодіють із різними
  програмами в мережі, де кожна інструкція представляє конкретну операцію.

- Кожна інструкція вказує програму для виконання інструкції, облікові записи,
  необхідні для інструкції, та дані, потрібні для виконання інструкції.

- Інструкції в транзакції обробляються в порядку, в якому вони вказані.

- Транзакції є атомарними, тобто або всі інструкції успішно обробляються, або
  вся транзакція провалюється.

- Максимальний розмір транзакції становить 1232 байти.

## Простий приклад

Нижче наведено діаграму, яка представляє транзакцію з однією інструкцією для
переказу SOL від відправника до отримувача.

Індивідуальні "гаманці" у Solana є обліковими записами, якими володіє
[Системна програма](/docs/uk/core/accounts#system-program). Як частина
[моделі облікових записів Solana](/docs/uk/core/accounts), лише програма, якій
належить обліковий запис, може змінювати дані цього облікового запису.

Тому для переказу SOL із облікового запису "гаманця" необхідно надіслати
транзакцію для виклику інструкції переказу у Системній програмі.

![Переказ SOL](/assets/docs/core/transactions/sol-transfer.svg)

Обліковий запис відправника має бути доданий як підписант (`is_signer`) до
транзакції, щоб схвалити списання балансу лампортів. Обидва облікові записи,
відправник і отримувач, мають бути змінюваними (`is_writable`), оскільки
інструкція змінює баланс лампортів для обох облікових записів.

Після відправлення транзакції викликається Системна програма для обробки
інструкції переказу. Потім Системна програма оновлює баланс лампортів для обох
облікових записів відповідно.

![Процес переказу SOL](/assets/docs/core/transactions/sol-transfer-process.svg)

### Простий переказ SOL

Ось приклад із
[Solana Playground](https://beta.solpg.io/656a0ea7fb53fa325bfd0c3e), який
демонструє, як створити інструкцію переказу SOL за допомогою методу
`SystemProgram.transfer`:

```typescript
// Визначення суми переказу
const transferAmount = 0.01; // 0.01 SOL

// Створення інструкції для переказу SOL з wallet_1 до wallet_2
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL, // Конвертація transferAmount у лампорти
});

// Додавання інструкції переказу до нової транзакції
const transaction = new Transaction().add(transferInstruction);
```

Запустіть скрипт і перевірте деталі транзакції, що виводяться в консоль. У
наступних розділах ми розглянемо, що відбувається "під капотом".

## Транзакція

Транзакція Solana
[transaction](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/src/transaction/mod.rs#L173)
складається з:

1. [Підписів](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/src/signature.rs#L27):
   Масиву підписів, включених у транзакцію.
2. [Повідомлення](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/program/src/message/legacy.rs#L110):
   Переліку інструкцій, які будуть оброблятися атомарно.

![Формат транзакції](/assets/docs/core/transactions/tx_format.png)

Структура повідомлення транзакції складається з:

- [Заголовка повідомлення](/docs/uk/core/transactions#message-header): Вказує
  кількість підписантів та облікових записів тільки для читання.
- [Масиву адрес облікових записів](/docs/uk/core/transactions#array-of-account-addresses):
  Масив адрес облікових записів, необхідних для інструкцій у транзакції.
- [Недавнього блоку хешу](/docs/uk/core/transactions#recent-blockhash):
  Використовується як мітка часу для транзакції.
- [Масиву інструкцій](/docs/uk/core/transactions#array-of-instructions): Масив
  інструкцій, які слід виконати.

![Повідомлення транзакції](/assets/docs/core/transactions/legacy_message.png)

### Розмір транзакції

Мережа Solana дотримується максимального розміру пакета (MTU) у 1280 байт, що
відповідає [MTU IPv6](https://en.wikipedia.org/wiki/IPv6_packet). Це забезпечує
швидку та надійну передачу інформації у кластері через UDP. Після врахування
необхідних заголовків (40 байт для IPv6 та 8 байт для заголовка фрагмента),
[1232 байти залишаються для даних пакета](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/src/packet.rs#L16-L21),
таких як серіалізовані транзакції.

Це означає, що загальний розмір транзакції Solana обмежений 1232 байтами.
Підписи та повідомлення у комбінації не можуть перевищувати цей ліміт.

- Підписи: Кожен підпис займає 64 байти. Кількість підписів може варіювати
  залежно від вимог транзакції.
- Повідомлення: Повідомлення включає інструкції, облікові записи та додаткові
  метадані. Кожен обліковий запис займає 32 байти. Загальний розмір облікових
  записів плюс метадані може варіювати залежно від інструкцій у транзакції.

![Формат транзакції](/assets/docs/core/transactions/issues_with_legacy_txs.png)

### Заголовок повідомлення

[Заголовок повідомлення](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/program/src/message/mod.rs#L96)
вказує на привілеї облікових записів, включених у масив адрес транзакції. Він
складається з трьох байтів, кожен з яких містить ціле число типу u8, що
колективно вказує:

1. Кількість необхідних підписів для транзакції.
2. Кількість облікових записів тільки для читання, які потребують підписів.
3. Кількість облікових записів тільки для читання, які не потребують підписів.

![Заголовок повідомлення](/assets/docs/core/transactions/message_header.png)

### Формат компактного масиву

Компактний масив у контексті повідомлення транзакції посилається на масив,
серіалізований у наступному форматі:

1. Довжина масиву, закодована як
   [compact-u16](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/program/src/short_vec.rs).
2. Окремі елементи масиву, перераховані послідовно після закодованої довжини.

![Формат компактного масиву](/assets/docs/core/transactions/compact_array_format.png)

Цей метод кодування використовується для вказівки довжин як
[масиву адрес облікових записів](/docs/uk/core/transactions#array-of-account-addresses),
так і [масиву інструкцій](/docs/uk/core/transactions#array-of-instructions) у
повідомленні транзакції.

### Масив адрес облікових записів

Повідомлення транзакції включає масив, що містить усі
[адреси облікових записів](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/program/src/message/legacy.rs#L119),
необхідні для інструкцій у транзакції.

Цей масив починається з кодування
[compact-u16](/docs/uk/core/transactions#compact-array-format) довжини масиву,
після чого йдуть адреси, впорядковані за привілеями облікових записів. Метадані
в заголовку повідомлення використовуються для визначення кількості облікових
записів у кожному розділі.

- Облікові записи, що є змінюваними та підписантами.
- Облікові записи тільки для читання, що є підписантами.
- Облікові записи, що є змінюваними, але не підписантами.
- Облікові записи тільки для читання, що не є підписантами.

![Компактний масив адрес облікових записів](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### Недавній блок-хеш

Усі транзакції включають
[недавній блок-хеш](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/program/src/message/legacy.rs#L122),
який використовується як мітка часу для транзакції. Блок-хеш запобігає
дублюванню транзакцій і виключає застарілі транзакції.

Максимальний вік блок-хеша для транзакції становить 150 блоків (~1 хвилина, якщо
час блоку складає 400 мс). Якщо блок-хеш транзакції старіший за 150 блоків від
останнього блок-хеша, вона вважається протермінованою. Це означає, що
транзакції, які не були оброблені вчасно, ніколи не будуть виконані.

Ви можете скористатися RPC-методом
[`getLatestBlockhash`](/docs/uk/rpc/http/getlatestblockhash), щоб отримати
поточний блок-хеш і останню висоту блоку, на якій блок-хеш залишатиметься
дійсним. Ось приклад у
[Solana Playground](https://beta.solpg.io/661a06e1cffcf4b13384d046).

### Масив інструкцій

Повідомлення транзакції включає масив усіх
[інструкцій](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/program/src/message/legacy.rs#L128),
які запитуються для обробки. Інструкції у повідомленні транзакції мають формат
[CompiledInstruction](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/program/src/instruction.rs#L633).

Подібно до масиву адрес облікових записів, цей компактний масив починається з
кодування [compact-u16](/docs/uk/core/transactions#compact-array-format)
кількості інструкцій, після чого йде масив інструкцій. Кожна інструкція в масиві
вказує наступну інформацію:

1. **Program ID**: Ідентифікатор програми в мережі, яка оброблятиме інструкцію.
   Це представлено у вигляді індексу типу u8, що вказує на адресу програми у
   масиві адрес облікових записів.
2. **Компактний масив індексів адрес облікових записів**: Масив індексів типу
   u8, що вказує на масив адрес облікових записів для кожного облікового запису,
   потрібного для інструкції.
3. **Компактний масив байтів даних**: Масив байтів типу u8, специфічний для
   викликаної програми. Ці дані вказують, яку інструкцію викликати у програмі,
   разом із будь-якими додатковими даними, потрібними для виконання інструкції
   (наприклад, аргументами функції).

![Компактний масив інструкцій](/assets/docs/core/transactions/compact_array_of_ixs.png)

### Приклад структури транзакції

Нижче наведено приклад структури транзакції, яка включає одну інструкцію для
[передачі SOL](/docs/uk/core/transactions#basic-example). Тут показано деталі
повідомлення, включаючи заголовок, ключі облікових записів, блок-хеш та
інструкції, разом із підписом для транзакції.

- `header`: Містить дані, які використовуються для вказання привілеїв
  читання/запису та підписання у масиві `accountKeys`.
- `accountKeys`: Масив, що включає адреси облікових записів для всіх інструкцій
  у транзакції.
- `recentBlockhash`: Блок-хеш, включений у транзакцію під час її створення.
- `instructions`: Масив, що включає всі інструкції у транзакції. Кожен `account`
  та `programIdIndex` в інструкції посилаються на масив `accountKeys` за
  індексом.
- `signatures`: Масив, що включає підписи для всіх облікових записів, потрібних
  як підписанти для інструкцій у транзакції. Підпис створюється шляхом
  підписання повідомлення транзакції за допомогою відповідного приватного ключа
  для облікового запису.

```json
"transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
        "5snoUseZG8s8CDFHrXY2ZHaCrJYsW457piktDmhyb5Jd",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "DzfXchZJoLMG3cNftcf2sw7qatkkuwQf4xH15N5wkKAb",
      "instructions": [
        {
          "accounts": [
            0,
            1
          ],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "5LrcE2f6uvydKRquEJ8xp19heGxSvqsVbcqUeFoiWbXe8JNip7ftPQNTAVPyTK7ijVdpkzmKKaAQR7MWMmujAhXD"
    ]
  }
```

## Інструкція

[Інструкція](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/program/src/instruction.rs#L329)
— це запит на виконання конкретної дії в мережі. Це найменша неподільна одиниця
логіки виконання у [програмі](/docs/uk/core/accounts#program-account).

При створенні інструкції для додавання до транзакції кожна інструкція повинна
включати наступну інформацію:

- **Адреса програми**: Вказує програму, яку буде викликано.
- **Облікові записи**: Перелік кожного облікового запису, з якого інструкція
  читає або до якого пише, включаючи інші програми, за допомогою структури
  `AccountMeta`.
- **Дані інструкції**: Масив байтів, що вказує, який
  [обробник інструкцій](/docs/uk/terminology#instruction-handler) викликати у
  програмі, а також будь-які додаткові дані, необхідні обробнику інструкцій
  (аргументи функції).

![Інструкція транзакції](/assets/docs/core/transactions/instruction.svg)

### AccountMeta

Для кожного облікового запису, необхідного для інструкції, потрібно вказати
наступну інформацію:

- `pubkey`: Адреса облікового запису в мережі.
- `is_signer`: Вказує, чи є обліковий запис підписантом у транзакції.
- `is_writable`: Вказує, чи будуть змінені дані облікового запису.

Ця інформація називається
[AccountMeta](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/program/src/instruction.rs#L539).

![AccountMeta](/assets/docs/core/transactions/accountmeta.svg)

Завдяки вказанню всіх облікових записів, необхідних для інструкції, і
зазначенню, які з них можуть бути змінені, транзакції можуть виконуватися
паралельно.

Наприклад, дві транзакції, які не включають жодних облікових записів, що
записують в той самий стан, можуть виконуватися одночасно.

### Приклад структури інструкції

Нижче наведено приклад структури інструкції для
[передачі SOL](/docs/uk/core/transactions#basic-examples), яка деталізує ключі
облікових записів, ідентифікатор програми та дані, необхідні для інструкції.

- `keys`: Містить `AccountMeta` для кожного облікового запису, необхідного для
  інструкції.
- `programId`: Адреса програми, яка містить логіку виконання для викликаної
  інструкції.
- `data`: Дані інструкції у вигляді буфера байтів.

```
{
  "keys": [
    {
      "pubkey": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
      "isSigner": true,
      "isWritable": true
    },
    {
      "pubkey": "BpvxsLYKQZTH42jjtWHZpsVSa7s6JVwLKwBptPSHXuZc",
      "isSigner": false,
      "isWritable": true
    }
  ],
  "programId": "11111111111111111111111111111111",
  "data": [2,0,0,0,128,150,152,0,0,0,0,0]
}
```

## Розширений приклад

Деталі створення програмних інструкцій часто приховуються клієнтськими
бібліотеками. Проте, якщо такої бібліотеки немає, завжди можна вручну створити
інструкцію.

### Ручна передача SOL

Ось приклад на
[Solana Playground](https://beta.solpg.io/656a102efb53fa325bfd0c3f), який
демонструє, як вручну створити інструкцію для передачі SOL:

```typescript
// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Instruction index for the SystemProgram transfer instruction
const transferInstructionIndex = 2;

// Create a buffer for the data to be passed to the transfer instruction
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
// Write the instruction index to the buffer
instructionData.writeUInt32LE(transferInstructionIndex, 0);
// Write the transfer amount to the buffer
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// Manually create a transfer instruction for transferring SOL from sender to receiver
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true },
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true },
  ],
  programId: SystemProgram.programId,
  data: instructionData,
});

// Add the transfer instruction to a new transaction
const transaction = new Transaction().add(transferInstruction);
```

Під капотом [простий приклад](/docs/uk/core/transactions#simple-sol-transfer) з
використанням методу `SystemProgram.transfer` функціонально еквівалентний більш
детальному прикладу вище. Метод `SystemProgram.transfer` просто приховує деталі
створення буфера даних інструкції та `AccountMeta` для кожного облікового
запису, необхідного для інструкції.
