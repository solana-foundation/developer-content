---
title: "Часто задавані питання"
sidebarSortOrder: 7
---

Публікуйте свої питання на
[StackExchange](https://solana.stackexchange.com/questions/ask).

## Berkeley Packet Filter (BPF)

Програми Solana на ланцюзі компілюються через
[інфраструктуру компілятора LLVM](https://llvm.org/) в
[Executable and Linkable Format (ELF)](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format),
яка містить варіацію
[Berkeley Packet Filter (BPF)](https://en.wikipedia.org/wiki/Berkeley_Packet_Filter)
байткоду.

Оскільки Solana використовує інфраструктуру компілятора LLVM, програму можна написати
на будь-якій мові програмування, яка підтримує компіляцію в BPF бекенд LLVM.

BPF надає ефективний
[набір інструкцій](https://github.com/iovisor/bpf-docs/blob/master/eBPF.md),
який можна виконувати в інтерпретованій віртуальній машині або як ефективно згенеровані
нативні інструкції за допомогою just-in-time компіляції.

## Карта пам'яті

Віртуальна адресна карта пам'яті, яку використовують програми Solana SBF, є фіксованою
та має наступне розташування:

- Код програми починається з адреси 0x100000000
- Дані стека починаються з адреси 0x200000000
- Дані купи починаються з адреси 0x300000000
- Вхідні параметри програми починаються з адреси 0x400000000

Вищезазначені віртуальні адреси є початковими адресами, але програми отримують доступ до
підмножини карти пам'яті. Програма викликає паніку, якщо вона намагається читати або
записувати в віртуальну адресу, до якої не було надано доступу, і повертається помилка
`AccessViolation`, яка містить адресу та розмір спроби порушення.

## InvalidAccountData

Ця помилка програми може статися з багатьох причин. Зазвичай це викликано
передачею акаунта в програму, якого програма не очікує, або через неправильне
положення акаунта в інструкції або акаунт, який не сумісний з виконуваною інструкцією.

Реалізація програми може також спричинити цю помилку при виконанні
перехресної інструкції між програмами, якщо забули надати акаунт для програми,
яку ви викликаєте.

## InvalidInstructionData

Ця помилка програми може статися при спробі десеріалізувати інструкцію, перевірте,
чи структура, передана в інструкцію, точно відповідає вимогам програми. Між полями
може бути деяке додаткове заповнення. Якщо програма реалізує трейти Rust `Pack`, спробуйте
упакувати і розпакувати тип інструкції `T`, щоб визначити точне кодування,
яке програма очікує.

## MissingRequiredSignature

Деякі інструкції вимагають, щоб акаунт був підписантом; ця помилка повертається, якщо
очікується підпис акаунта, але він відсутній.

Реалізація програми може також викликати цю помилку при виконанні
[перехресного виклику програми](/docs/core/cpi.md), який вимагає підписаного адреси програми,
але передані насіння підписувача до `invoke_signed` не збігаються з
насіннями підписувача, що використовуються для створення адреси програми
[`create_program_address`](/docs/core/pda.md#createprogramaddress).

## Стек

SBF використовує стекові кадри замість змінного покажчика стеку. Кожен стековий кадр
має розмір 4 КБ.

Якщо програма порушує розмір цього стекового кадру, компілятор повідомить
про перевищення розміру як попередження.

Наприклад:

```text
Error: Function _ZN16curve25519_dalek7edwards21EdwardsBasepointTable6create17h178b3d2411f7f082E Stack offset of -30728 exceeded max offset of -4096 by 26632 bytes, please minimize large stack variables
```

Повідомлення вказує, який символ перевищує розмір свого стекового кадру, але ім'я може бути змінене.

> Щоб деманглювати символ Rust, використовуйте [rustfilt](https://github.com/luser/rustfilt).

Вищезазначене попередження походить від програми на Rust, тому демангльоване ім'я символу:


```shell
rustfilt _ZN16curve25519_dalek7edwards21EdwardsBasepointTable6create17h178b3d2411f7f082E
curve25519_dalek::edwards::EdwardsBasepointTable::create
```
Причина того, що виводиться попередження, а не помилка, полягає в тому, що деякі залежні
пакети можуть містити функціональність, яка порушує обмеження розміру стекового кадру, навіть
якщо програма не використовує цю функціональність. Якщо програма порушить розмір стеку під час виконання,
то буде виведено помилку `AccessViolation`.

Стекові кадри SBF займають діапазон віртуальних адрес, починаючи з `0x200000000`.

## Розмір купи

Програми мають доступ до купи часу виконання через API Rust `alloc`. Для
швидкого виділення пам'яті використовується проста купа на 32 КБ. Куча не підтримує
`free` або `realloc`.

Програми мають доступ до пам'яті об'ємом 32 КБ, починаючи з віртуальної
адреси 0x300000000, і можуть реалізувати власну купу на основі специфічних потреб програми.

Програми на Rust реалізують купу безпосередньо, визначаючи власний
[`global_allocator`](https://github.com/solana-labs/solana/blob/d9b0fc0e3eec67dfe4a97d9298b15969b2804fab/sdk/program/src/entrypoint.rs#L72)

## Завантажувачі

Програми розгортаються і виконуються через завантажувачі часу виконання, наразі підтримуються
два завантажувачі:
- [BPF Loader](https://github.com/solana-labs/solana/blob/7ddf10e602d2ed87a9e3737aa8c32f1db9f909d8/sdk/program/src/bpf_loader.rs#L17)
- [BPF loader (deprecated)](https://github.com/solana-labs/solana/blob/7ddf10e602d2ed87a9e3737aa8c32f1db9f909d8/sdk/program/src/bpf_loader_deprecated.rs#L14)

Завантажувачі можуть підтримувати різні інтерфейси бінарних додатків, тому розробники повинні
пишуть свої програми для одного завантажувача і розгортають їх на тому ж завантажувачі. Якщо програма,
написана для одного завантажувача, буде розгорнута на іншому, це зазвичай призведе до
помилки `AccessViolation` через невідповідність десеріалізації вхідних параметрів програми.

Для практичних цілей програми завжди повинні бути написані для останнього
BPF завантажувача, і останній завантажувач є за умовчанням для інтерфейсу командного рядка
та JavaScript API.

- [Точки входу програми Rust](/docs/programs/lang-rust.md#program-entrypoint)

### Розгортання

Розгортання програми SBF — це процес завантаження спільного об'єкта BPF в
дані акаунта програми та позначення акаунта як виконуваного. Клієнт розбиває
спільний об'єкт SBF на менші частини і надсилає їх як дані інструкцій
[`Write`](https://github.com/solana-labs/solana/blob/bc7133d7526a041d1aaee807b80922baa89b6f90/sdk/program/src/loader_instruction.rs#L13)
до завантажувача, де завантажувач записує ці дані в акаунт програми.
Якщо всі частини отримані, клієнт надсилає
[`Finalize`](https://github.com/solana-labs/solana/blob/bc7133d7526a041d1aaee807b80922baa89b6f90/sdk/program/src/loader_instruction.rs#L30)
інструкцію до завантажувача, завантажувач потім перевіряє, чи є дані SBF дійсними
і позначає акаунт програми як _виконуваний_. Після того, як акаунт програми
буде позначено як виконуваний, подальші транзакції можуть видавати інструкції для цієї
програми для обробки.

Коли інструкція спрямована до виконуваної програми SBF, завантажувач
конфігурує середовище виконання програми, серіалізує вхідні параметри програми,
викликає точку входу програми і повідомляє про будь-які помилки.

Додаткову інформацію див. в розділі [розгортання програм](/docs/programs/deploying.md).

### Серіалізація вхідних параметрів

Завантажувачі SBF серіалізують вхідні параметри програми в масив байтів, який потім передається
в точку входу програми, де програма відповідає за їх десеріалізацію на ланцюгу. Одна з змін між
депрецованим завантажувачем і поточним полягає в тому, що вхідні параметри серіалізуються так,
що різні параметри потрапляють на вирівняні офсети в межах вирівняного байтового
масиву. Це дозволяє реалізаціям десеріалізації безпосередньо посилатися на
байтовий масив і надавати вирівняні вказівники до програми.

- [Десеріалізація параметрів програми на Rust](/docs/programs/lang-rust.md#parameter-deserialization)

Останній завантажувач серіалізує вхідні параметри програми наступним чином (усе
кодування little endian):

- 8 байт беззнакового числа акаунтів
- Для кожного акаунта:
  - 1 байт, що вказує, чи є цей акаунт дублікатом, якщо ні — значення 0xff,
    в іншому випадку значення — це індекс акаунта, з яким він є дублікатом.
  - Якщо дублікати: 7 байт заповнювальної пам'яті
  - Якщо не дублікати:
    - 1 байт булевого типу, true, якщо акаунт є підписантом
    - 1 байт булевого типу, true, якщо акаунт можна змінювати
    - 1 байт булевого типу, true, якщо акаунт є виконуваним
    - 4 байти заповнювальної пам'яті
    - 32 байти публічного ключа акаунта
    - 32 байти публічного ключа власника акаунта
    - 8 байт беззнакового числа лампортів, які належать акаунту
    - 8 байт беззнакового числа байтів даних акаунта
    - x байт даних акаунта
    - 10к байт заповнювальної пам'яті, використовується для realloc
    - достатньо заповнювальної пам'яті для вирівнювання офсету до 8 байт
    - 8 байт епохи оренди
- 8 байт беззнакового числа даних інструкцій
- x байт даних інструкцій
- 32 байти ID програми
